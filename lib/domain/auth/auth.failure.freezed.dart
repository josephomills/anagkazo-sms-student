// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth.failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AuthFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthFailureCopyWith<$Res> {
  factory $AuthFailureCopyWith(
          AuthFailure value, $Res Function(AuthFailure) then) =
      _$AuthFailureCopyWithImpl<$Res, AuthFailure>;
}

/// @nodoc
class _$AuthFailureCopyWithImpl<$Res, $Val extends AuthFailure>
    implements $AuthFailureCopyWith<$Res> {
  _$AuthFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_CancelledByUserCopyWith<$Res> {
  factory _$$_CancelledByUserCopyWith(
          _$_CancelledByUser value, $Res Function(_$_CancelledByUser) then) =
      __$$_CancelledByUserCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CancelledByUserCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_CancelledByUser>
    implements _$$_CancelledByUserCopyWith<$Res> {
  __$$_CancelledByUserCopyWithImpl(
      _$_CancelledByUser _value, $Res Function(_$_CancelledByUser) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_CancelledByUser implements _CancelledByUser {
  const _$_CancelledByUser();

  @override
  String toString() {
    return 'AuthFailure.cancelledByUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_CancelledByUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return cancelledByUser();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return cancelledByUser?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (cancelledByUser != null) {
      return cancelledByUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return cancelledByUser(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return cancelledByUser?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (cancelledByUser != null) {
      return cancelledByUser(this);
    }
    return orElse();
  }
}

abstract class _CancelledByUser implements AuthFailure {
  const factory _CancelledByUser() = _$_CancelledByUser;
}

/// @nodoc
abstract class _$$_ServerErrorCopyWith<$Res> {
  factory _$$_ServerErrorCopyWith(
          _$_ServerError value, $Res Function(_$_ServerError) then) =
      __$$_ServerErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String? message});
}

/// @nodoc
class __$$_ServerErrorCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_ServerError>
    implements _$$_ServerErrorCopyWith<$Res> {
  __$$_ServerErrorCopyWithImpl(
      _$_ServerError _value, $Res Function(_$_ServerError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$_ServerError(
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_ServerError implements _ServerError {
  const _$_ServerError({this.message});

  @override
  final String? message;

  @override
  String toString() {
    return 'AuthFailure.serverError(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ServerError &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ServerErrorCopyWith<_$_ServerError> get copyWith =>
      __$$_ServerErrorCopyWithImpl<_$_ServerError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return serverError(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return serverError?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class _ServerError implements AuthFailure {
  const factory _ServerError({final String? message}) = _$_ServerError;

  String? get message;
  @JsonKey(ignore: true)
  _$$_ServerErrorCopyWith<_$_ServerError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UsernameAlreadyInUseCopyWith<$Res> {
  factory _$$_UsernameAlreadyInUseCopyWith(_$_UsernameAlreadyInUse value,
          $Res Function(_$_UsernameAlreadyInUse) then) =
      __$$_UsernameAlreadyInUseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UsernameAlreadyInUseCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_UsernameAlreadyInUse>
    implements _$$_UsernameAlreadyInUseCopyWith<$Res> {
  __$$_UsernameAlreadyInUseCopyWithImpl(_$_UsernameAlreadyInUse _value,
      $Res Function(_$_UsernameAlreadyInUse) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UsernameAlreadyInUse implements _UsernameAlreadyInUse {
  const _$_UsernameAlreadyInUse();

  @override
  String toString() {
    return 'AuthFailure.usernameAlreadyInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_UsernameAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return usernameAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return usernameAlreadyInUse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (usernameAlreadyInUse != null) {
      return usernameAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return usernameAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return usernameAlreadyInUse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (usernameAlreadyInUse != null) {
      return usernameAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class _UsernameAlreadyInUse implements AuthFailure {
  const factory _UsernameAlreadyInUse() = _$_UsernameAlreadyInUse;
}

/// @nodoc
abstract class _$$_EmailAlreadyInUseCopyWith<$Res> {
  factory _$$_EmailAlreadyInUseCopyWith(_$_EmailAlreadyInUse value,
          $Res Function(_$_EmailAlreadyInUse) then) =
      __$$_EmailAlreadyInUseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_EmailAlreadyInUseCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_EmailAlreadyInUse>
    implements _$$_EmailAlreadyInUseCopyWith<$Res> {
  __$$_EmailAlreadyInUseCopyWithImpl(
      _$_EmailAlreadyInUse _value, $Res Function(_$_EmailAlreadyInUse) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_EmailAlreadyInUse implements _EmailAlreadyInUse {
  const _$_EmailAlreadyInUse();

  @override
  String toString() {
    return 'AuthFailure.emailAlreadyInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_EmailAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return emailAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return emailAlreadyInUse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return emailAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return emailAlreadyInUse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class _EmailAlreadyInUse implements AuthFailure {
  const factory _EmailAlreadyInUse() = _$_EmailAlreadyInUse;
}

/// @nodoc
abstract class _$$_WeakPasswordCopyWith<$Res> {
  factory _$$_WeakPasswordCopyWith(
          _$_WeakPassword value, $Res Function(_$_WeakPassword) then) =
      __$$_WeakPasswordCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_WeakPasswordCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_WeakPassword>
    implements _$$_WeakPasswordCopyWith<$Res> {
  __$$_WeakPasswordCopyWithImpl(
      _$_WeakPassword _value, $Res Function(_$_WeakPassword) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_WeakPassword implements _WeakPassword {
  const _$_WeakPassword();

  @override
  String toString() {
    return 'AuthFailure.weakPassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_WeakPassword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return weakPassword();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return weakPassword?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (weakPassword != null) {
      return weakPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return weakPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return weakPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (weakPassword != null) {
      return weakPassword(this);
    }
    return orElse();
  }
}

abstract class _WeakPassword implements AuthFailure {
  const factory _WeakPassword() = _$_WeakPassword;
}

/// @nodoc
abstract class _$$_InvalidEmailAndPasswordCombinationCopyWith<$Res> {
  factory _$$_InvalidEmailAndPasswordCombinationCopyWith(
          _$_InvalidEmailAndPasswordCombination value,
          $Res Function(_$_InvalidEmailAndPasswordCombination) then) =
      __$$_InvalidEmailAndPasswordCombinationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InvalidEmailAndPasswordCombinationCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res,
        _$_InvalidEmailAndPasswordCombination>
    implements _$$_InvalidEmailAndPasswordCombinationCopyWith<$Res> {
  __$$_InvalidEmailAndPasswordCombinationCopyWithImpl(
      _$_InvalidEmailAndPasswordCombination _value,
      $Res Function(_$_InvalidEmailAndPasswordCombination) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_InvalidEmailAndPasswordCombination
    implements _InvalidEmailAndPasswordCombination {
  const _$_InvalidEmailAndPasswordCombination();

  @override
  String toString() {
    return 'AuthFailure.invalidUsernameAndPasswordCombination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_InvalidEmailAndPasswordCombination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return invalidUsernameAndPasswordCombination();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return invalidUsernameAndPasswordCombination?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (invalidUsernameAndPasswordCombination != null) {
      return invalidUsernameAndPasswordCombination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return invalidUsernameAndPasswordCombination(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return invalidUsernameAndPasswordCombination?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (invalidUsernameAndPasswordCombination != null) {
      return invalidUsernameAndPasswordCombination(this);
    }
    return orElse();
  }
}

abstract class _InvalidEmailAndPasswordCombination implements AuthFailure {
  const factory _InvalidEmailAndPasswordCombination() =
      _$_InvalidEmailAndPasswordCombination;
}

/// @nodoc
abstract class _$$_UserDoesNotExistCopyWith<$Res> {
  factory _$$_UserDoesNotExistCopyWith(
          _$_UserDoesNotExist value, $Res Function(_$_UserDoesNotExist) then) =
      __$$_UserDoesNotExistCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UserDoesNotExistCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_UserDoesNotExist>
    implements _$$_UserDoesNotExistCopyWith<$Res> {
  __$$_UserDoesNotExistCopyWithImpl(
      _$_UserDoesNotExist _value, $Res Function(_$_UserDoesNotExist) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UserDoesNotExist implements _UserDoesNotExist {
  const _$_UserDoesNotExist();

  @override
  String toString() {
    return 'AuthFailure.userDoesNotExist()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_UserDoesNotExist);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return userDoesNotExist();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return userDoesNotExist?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (userDoesNotExist != null) {
      return userDoesNotExist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return userDoesNotExist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return userDoesNotExist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (userDoesNotExist != null) {
      return userDoesNotExist(this);
    }
    return orElse();
  }
}

abstract class _UserDoesNotExist implements AuthFailure {
  const factory _UserDoesNotExist() = _$_UserDoesNotExist;
}

/// @nodoc
abstract class _$$_WrongPasswordCopyWith<$Res> {
  factory _$$_WrongPasswordCopyWith(
          _$_WrongPassword value, $Res Function(_$_WrongPassword) then) =
      __$$_WrongPasswordCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_WrongPasswordCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_WrongPassword>
    implements _$$_WrongPasswordCopyWith<$Res> {
  __$$_WrongPasswordCopyWithImpl(
      _$_WrongPassword _value, $Res Function(_$_WrongPassword) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_WrongPassword implements _WrongPassword {
  const _$_WrongPassword();

  @override
  String toString() {
    return 'AuthFailure.wrongPassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_WrongPassword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return wrongPassword();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return wrongPassword?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (wrongPassword != null) {
      return wrongPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return wrongPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return wrongPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (wrongPassword != null) {
      return wrongPassword(this);
    }
    return orElse();
  }
}

abstract class _WrongPassword implements AuthFailure {
  const factory _WrongPassword() = _$_WrongPassword;
}

/// @nodoc
abstract class _$$_PlatformFailureCopyWith<$Res> {
  factory _$$_PlatformFailureCopyWith(
          _$_PlatformFailure value, $Res Function(_$_PlatformFailure) then) =
      __$$_PlatformFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PlatformFailureCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_PlatformFailure>
    implements _$$_PlatformFailureCopyWith<$Res> {
  __$$_PlatformFailureCopyWithImpl(
      _$_PlatformFailure _value, $Res Function(_$_PlatformFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_PlatformFailure implements _PlatformFailure {
  const _$_PlatformFailure();

  @override
  String toString() {
    return 'AuthFailure.platformFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_PlatformFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return platformFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return platformFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (platformFailure != null) {
      return platformFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return platformFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return platformFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (platformFailure != null) {
      return platformFailure(this);
    }
    return orElse();
  }
}

abstract class _PlatformFailure implements AuthFailure {
  const factory _PlatformFailure() = _$_PlatformFailure;
}

/// @nodoc
abstract class _$$_SessionMissingCopyWith<$Res> {
  factory _$$_SessionMissingCopyWith(
          _$_SessionMissing value, $Res Function(_$_SessionMissing) then) =
      __$$_SessionMissingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SessionMissingCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_SessionMissing>
    implements _$$_SessionMissingCopyWith<$Res> {
  __$$_SessionMissingCopyWithImpl(
      _$_SessionMissing _value, $Res Function(_$_SessionMissing) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SessionMissing implements _SessionMissing {
  const _$_SessionMissing();

  @override
  String toString() {
    return 'AuthFailure.sessionMissing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SessionMissing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return sessionMissing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return sessionMissing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (sessionMissing != null) {
      return sessionMissing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return sessionMissing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return sessionMissing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (sessionMissing != null) {
      return sessionMissing(this);
    }
    return orElse();
  }
}

abstract class _SessionMissing implements AuthFailure {
  const factory _SessionMissing() = _$_SessionMissing;
}

/// @nodoc
abstract class _$$_InvalidSessionTokenCopyWith<$Res> {
  factory _$$_InvalidSessionTokenCopyWith(_$_InvalidSessionToken value,
          $Res Function(_$_InvalidSessionToken) then) =
      __$$_InvalidSessionTokenCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InvalidSessionTokenCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_InvalidSessionToken>
    implements _$$_InvalidSessionTokenCopyWith<$Res> {
  __$$_InvalidSessionTokenCopyWithImpl(_$_InvalidSessionToken _value,
      $Res Function(_$_InvalidSessionToken) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_InvalidSessionToken implements _InvalidSessionToken {
  const _$_InvalidSessionToken();

  @override
  String toString() {
    return 'AuthFailure.invalidSessionToken()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InvalidSessionToken);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return invalidSessionToken();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return invalidSessionToken?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (invalidSessionToken != null) {
      return invalidSessionToken();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return invalidSessionToken(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return invalidSessionToken?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (invalidSessionToken != null) {
      return invalidSessionToken(this);
    }
    return orElse();
  }
}

abstract class _InvalidSessionToken implements AuthFailure {
  const factory _InvalidSessionToken() = _$_InvalidSessionToken;
}

/// @nodoc
abstract class _$$_AccountAlreadyInUseCopyWith<$Res> {
  factory _$$_AccountAlreadyInUseCopyWith(_$_AccountAlreadyInUse value,
          $Res Function(_$_AccountAlreadyInUse) then) =
      __$$_AccountAlreadyInUseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AccountAlreadyInUseCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$_AccountAlreadyInUse>
    implements _$$_AccountAlreadyInUseCopyWith<$Res> {
  __$$_AccountAlreadyInUseCopyWithImpl(_$_AccountAlreadyInUse _value,
      $Res Function(_$_AccountAlreadyInUse) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AccountAlreadyInUse implements _AccountAlreadyInUse {
  const _$_AccountAlreadyInUse();

  @override
  String toString() {
    return 'AuthFailure.accountAlreadyInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AccountAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledByUser,
    required TResult Function(String? message) serverError,
    required TResult Function() usernameAlreadyInUse,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() weakPassword,
    required TResult Function() invalidUsernameAndPasswordCombination,
    required TResult Function() userDoesNotExist,
    required TResult Function() wrongPassword,
    required TResult Function() platformFailure,
    required TResult Function() sessionMissing,
    required TResult Function() invalidSessionToken,
    required TResult Function() accountAlreadyInUse,
  }) {
    return accountAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? cancelledByUser,
    TResult? Function(String? message)? serverError,
    TResult? Function()? usernameAlreadyInUse,
    TResult? Function()? emailAlreadyInUse,
    TResult? Function()? weakPassword,
    TResult? Function()? invalidUsernameAndPasswordCombination,
    TResult? Function()? userDoesNotExist,
    TResult? Function()? wrongPassword,
    TResult? Function()? platformFailure,
    TResult? Function()? sessionMissing,
    TResult? Function()? invalidSessionToken,
    TResult? Function()? accountAlreadyInUse,
  }) {
    return accountAlreadyInUse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledByUser,
    TResult Function(String? message)? serverError,
    TResult Function()? usernameAlreadyInUse,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? weakPassword,
    TResult Function()? invalidUsernameAndPasswordCombination,
    TResult Function()? userDoesNotExist,
    TResult Function()? wrongPassword,
    TResult Function()? platformFailure,
    TResult Function()? sessionMissing,
    TResult Function()? invalidSessionToken,
    TResult Function()? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (accountAlreadyInUse != null) {
      return accountAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelledByUser value) cancelledByUser,
    required TResult Function(_ServerError value) serverError,
    required TResult Function(_UsernameAlreadyInUse value) usernameAlreadyInUse,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_WeakPassword value) weakPassword,
    required TResult Function(_InvalidEmailAndPasswordCombination value)
        invalidUsernameAndPasswordCombination,
    required TResult Function(_UserDoesNotExist value) userDoesNotExist,
    required TResult Function(_WrongPassword value) wrongPassword,
    required TResult Function(_PlatformFailure value) platformFailure,
    required TResult Function(_SessionMissing value) sessionMissing,
    required TResult Function(_InvalidSessionToken value) invalidSessionToken,
    required TResult Function(_AccountAlreadyInUse value) accountAlreadyInUse,
  }) {
    return accountAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_CancelledByUser value)? cancelledByUser,
    TResult? Function(_ServerError value)? serverError,
    TResult? Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult? Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult? Function(_WeakPassword value)? weakPassword,
    TResult? Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult? Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(_WrongPassword value)? wrongPassword,
    TResult? Function(_PlatformFailure value)? platformFailure,
    TResult? Function(_SessionMissing value)? sessionMissing,
    TResult? Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult? Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
  }) {
    return accountAlreadyInUse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelledByUser value)? cancelledByUser,
    TResult Function(_ServerError value)? serverError,
    TResult Function(_UsernameAlreadyInUse value)? usernameAlreadyInUse,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_WeakPassword value)? weakPassword,
    TResult Function(_InvalidEmailAndPasswordCombination value)?
        invalidUsernameAndPasswordCombination,
    TResult Function(_UserDoesNotExist value)? userDoesNotExist,
    TResult Function(_WrongPassword value)? wrongPassword,
    TResult Function(_PlatformFailure value)? platformFailure,
    TResult Function(_SessionMissing value)? sessionMissing,
    TResult Function(_InvalidSessionToken value)? invalidSessionToken,
    TResult Function(_AccountAlreadyInUse value)? accountAlreadyInUse,
    required TResult orElse(),
  }) {
    if (accountAlreadyInUse != null) {
      return accountAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class _AccountAlreadyInUse implements AuthFailure {
  const factory _AccountAlreadyInUse() = _$_AccountAlreadyInUse;
}
